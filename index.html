<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bac à Sable Multijoueur 3D</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        
        /* UI : Radar */
        #radar-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #444;
            border-radius: 50%;
            overflow: hidden;
        }
        #radar-canvas { width: 100%; height: 100%; }

        /* UI : Chat Input */
        #chat-input-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none; /* Caché par défaut */
        }
        #chat-input {
            padding: 10px;
            width: 300px;
            border-radius: 20px;
            border: none;
            outline: none;
            background: rgba(255, 255, 255, 0.9);
        }

        /* UI : Bulles de Chat 3D (Overlay HTML) */
        .chat-bubble {
            position: absolute;
            background: white;
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 12px;
            pointer-events: none;
            transform: translate(-50%, -100%);
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s;
            font-weight: bold;
        }
        .chat-visible { opacity: 1; }
        
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="instructions">
        WASD/Flèches : Bouger<br>
        T : Parler (Entrée pour envoyer)
    </div>

    <!-- Radar -->
    <div id="radar-container">
        <canvas id="radar-canvas" width="150" height="150"></canvas>
    </div>

    <!-- Zone de texte pour le chat -->
    <div id="chat-input-container">
        <input type="text" id="chat-input" placeholder="Écrivez votre message..." maxlength="50">
    </div>

    <!-- Conteneur pour les bulles de chat -->
    <div id="chat-bubbles-container"></div>

    <!-- Scripts -->
    <!-- Socket.io est servi automatiquement par le serveur Node -->
    <script src="/socket.io/socket.io.js"></script>
    <!-- Three.js via CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- CONFIGURATION INITIALE ---
        const socket = io();
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Ciel bleu
        // Brouillard pour masquer les bords
        scene.fog = new THREE.Fog(0x87CEEB, 10, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- LUMIÈRES ---
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- ENVIRONNEMENT ---
        // Sol
        const groundGeo = new THREE.PlaneGeometry(100, 100);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Arbres statiques (décor)
        function createTree(x, z) {
            const trunkGeo = new THREE.CylinderGeometry(0.2, 0.2, 1, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 0.5;

            const leavesGeo = new THREE.ConeGeometry(1, 2, 8);
            const leavesMat = new THREE.MeshStandardMaterial({ color: 0x006400 });
            const leaves = new THREE.Mesh(leavesGeo, leavesMat);
            leaves.position.y = 1.5;

            const tree = new THREE.Group();
            tree.add(trunk);
            tree.add(leaves);
            tree.position.set(x, 0, z);
            
            tree.traverse((obj) => {
                if(obj.isMesh) {
                    obj.castShadow = true;
                    obj.receiveShadow = true;
                }
            });

            scene.add(tree);
        }
        // Ajouter quelques arbres aléatoires
        for(let i=0; i<20; i++) {
            createTree((Math.random() - 0.5) * 80, (Math.random() - 0.5) * 80);
        }

        // --- GESTION DES JOUEURS ---
        const otherPlayers = {}; // Stocke les meshs des autres joueurs
        let player; // Mon avatar local (Mesh)
        let playerId; // Mon ID socket

        // Création d'un avatar Robot simple
        function createAvatar(color, isLocal) {
            const group = new THREE.Group();

            // Corps
            const bodyGeo = new THREE.BoxGeometry(0.5, 0.8, 0.4);
            const bodyMat = new THREE.MeshStandardMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.6; // Monter pour que les pieds soient au sol
            body.castShadow = true;
            group.add(body);

            // Tête
            const headGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const headMat = new THREE.MeshStandardMaterial({ color: 0x999999 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.2;
            head.castShadow = true;
            group.add(head);
            
            // Yeux (pour voir l'orientation)
            const eyeGeo = new THREE.BoxGeometry(0.1, 0.05, 0.05);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.1, 1.25, 0.2);
            group.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.1, 1.25, 0.2);
            group.add(rightEye);

            // Bulle de chat (DOM Element Reference, pas ajouté à la scène Three.js)
            // On stockera la référence à l'élément DOM dans l'objet 3D pour un accès facile
            const bubble = document.createElement('div');
            bubble.className = 'chat-bubble';
            document.getElementById('chat-bubbles-container').appendChild(bubble);
            group.userData.chatBubble = bubble;
            group.userData.chatTimer = null;

            return group;
        }

        // --- SOCKET IO LOGIQUE ---

        // 1. Recevoir la liste des joueurs actuels
        socket.on('currentPlayers', (players) => {
            Object.keys(players).forEach((id) => {
                if (id === socket.id) {
                    // C'est moi
                    addPlayer(players[id]);
                } else {
                    // C'est un autre
                    addOtherPlayer(players[id]);
                }
            });
        });

        // 2. Un nouveau joueur arrive
        socket.on('newPlayer', (playerInfo) => {
            addOtherPlayer(playerInfo);
        });

        // 3. Un joueur se déconnecte
        socket.on('playerDisconnected', (id) => {
            removeOtherPlayer(id);
        });

        // 4. Mouvement d'un autre joueur
        socket.on('playerMoved', (playerInfo) => {
            if (otherPlayers[playerInfo.playerId]) {
                const p = otherPlayers[playerInfo.playerId];
                // Interpolation simple (pourrait être améliorée avec lerp)
                p.position.set(playerInfo.x, playerInfo.y, playerInfo.z);
                p.rotation.y = playerInfo.rotation;
            }
        });

        // 5. Réception d'un message Chat
        socket.on('chatMessage', (data) => {
            // Trouver qui a parlé
            let targetMesh = null;
            if (data.id === socket.id) targetMesh = player;
            else targetMesh = otherPlayers[data.id];

            if (targetMesh && targetMesh.userData.chatBubble) {
                const bubble = targetMesh.userData.chatBubble;
                bubble.innerText = data.text;
                bubble.classList.add('chat-visible');

                // Reset timer si existe
                if (targetMesh.userData.chatTimer) clearTimeout(targetMesh.userData.chatTimer);

                // Cacher après 5 secondes
                targetMesh.userData.chatTimer = setTimeout(() => {
                    bubble.classList.remove('chat-visible');
                }, 5000);
            }
        });

        // --- FONCTIONS UTILITAIRES JOUEURS ---

        function addPlayer(playerInfo) {
            player = createAvatar(playerInfo.color, true);
            player.position.set(playerInfo.x, playerInfo.y, playerInfo.z);
            scene.add(player);
            playerId = playerInfo.playerId;

            // Caméra attachée initialement
            updateCamera();
        }

        function addOtherPlayer(playerInfo) {
            const otherPlayer = createAvatar(playerInfo.color, false);
            otherPlayer.position.set(playerInfo.x, playerInfo.y, playerInfo.z);
            otherPlayer.rotation.y = playerInfo.rotation;
            
            otherPlayers[playerInfo.playerId] = otherPlayer;
            scene.add(otherPlayer);
        }

        function removeOtherPlayer(id) {
            if (otherPlayers[id]) {
                // Supprimer bulle de chat
                if(otherPlayers[id].userData.chatBubble) {
                    otherPlayers[id].userData.chatBubble.remove();
                }
                scene.remove(otherPlayers[id]);
                delete otherPlayers[id];
            }
        }

        // --- CONTRÔLES ---
        const keys = { w: false, a: false, s: false, d: false };
        const speed = 0.1;
        const rotateSpeed = 0.05;

        document.addEventListener('keydown', (e) => {
            // Si on écrit dans le chat, on ignore les mouvements
            if(document.activeElement === document.getElementById('chat-input')) {
                if(e.code === 'Enter') sendChat();
                if(e.code === 'Escape') toggleChat(false);
                return;
            }

            switch(e.key.toLowerCase()) {
                case 'w': case 'arrowup': keys.w = true; break;
                case 'a': case 'arrowleft': keys.a = true; break;
                case 's': case 'arrowdown': keys.s = true; break;
                case 'd': case 'arrowright': keys.d = true; break;
                case 't': 
                    e.preventDefault(); 
                    toggleChat(true); 
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.key.toLowerCase()) {
                case 'w': case 'arrowup': keys.w = false; break;
                case 'a': case 'arrowleft': keys.a = false; break;
                case 's': case 'arrowdown': keys.s = false; break;
                case 'd': case 'arrowright': keys.d = false; break;
            }
        });

        // --- LOGIQUE CHAT ---
        function toggleChat(show) {
            const inputContainer = document.getElementById('chat-input-container');
            const input = document.getElementById('chat-input');
            if(show) {
                inputContainer.style.display = 'block';
                input.focus();
                // Reset les touches de mouvement pour éviter que le perso continue de courir
                keys.w = keys.a = keys.s = keys.d = false; 
            } else {
                inputContainer.style.display = 'none';
                input.blur();
            }
        }

        function sendChat() {
            const input = document.getElementById('chat-input');
            const msg = input.value;
            if(msg.trim().length > 0) {
                socket.emit('chatMessage', msg);
            }
            input.value = '';
            toggleChat(false);
        }

        // --- BOUCLE DE JEU ---
        function animate() {
            requestAnimationFrame(animate);

            if (player) {
                let moved = false;

                // Rotation
                if (keys.a) { player.rotation.y += rotateSpeed; moved = true; }
                if (keys.d) { player.rotation.y -= rotateSpeed; moved = true; }

                // Mouvement avant/arrière
                if (keys.w || keys.s) {
                    const dir = keys.w ? 1 : -1;
                    const dx = Math.sin(player.rotation.y) * speed * dir;
                    const dz = Math.cos(player.rotation.y) * speed * dir;
                    
                    // Vérification simple des limites (Monde de 100x100 -> -50 à 50)
                    if(player.position.x + dx < 48 && player.position.x + dx > -48) player.position.x += dx;
                    if(player.position.z + dz < 48 && player.position.z + dz > -48) player.position.z += dz;
                    
                    moved = true;
                }

                if (moved) {
                    updateCamera();
                    // Envoyer le mouvement au serveur
                    socket.emit('playerMovement', {
                        x: player.position.x,
                        y: player.position.y,
                        z: player.position.z,
                        rotation: player.position.rotation.y
                    });
                }

                // Mettre à jour la position des bulles de chat (Projection 3D -> 2D)
                updateChatBubblePosition(player);
            }

            // Mettre à jour bulles des autres
            Object.values(otherPlayers).forEach(p => updateChatBubblePosition(p));

            updateRadar();
            renderer.render(scene, camera);
        }

        function updateCamera() {
            // Caméra TPS (Third Person) : Derrière et au-dessus
            const relativeOffset = new THREE.Vector3(0, 5, -8);
            const cameraOffset = relativeOffset.applyMatrix4(player.matrixWorld);
            camera.position.x = cameraOffset.x;
            camera.position.y = cameraOffset.y;
            camera.position.z = cameraOffset.z;
            camera.lookAt(player.position);
        }

        function updateChatBubblePosition(mesh) {
            if(!mesh || !mesh.userData.chatBubble) return;
            
            const bubble = mesh.userData.chatBubble;
            
            // Position de la tête (approximative)
            const pos = mesh.position.clone();
            pos.y += 2.0; // Au-dessus de la tête

            // Projection écran
            pos.project(camera);

            const x = (pos.x * .5 + .5) * window.innerWidth;
            const y = (-(pos.y * .5) + .5) * window.innerHeight;

            // Cacher si derrière la caméra
            if(pos.z > 1) {
                bubble.style.display = 'none';
            } else {
                bubble.style.display = 'block';
                bubble.style.left = `${x}px`;
                bubble.style.top = `${y}px`;
            }
        }

        // --- RADAR ---
        const radarCanvas = document.getElementById('radar-canvas');
        const radarCtx = radarCanvas.getContext('2d');
        const radarSize = 150;
        const radarRange = 40; // Rayon de détection in-game

        function updateRadar() {
            if (!player) return;

            // Fond
            radarCtx.fillStyle = '#000';
            radarCtx.fillRect(0, 0, radarSize, radarSize);

            // Lignes
            radarCtx.strokeStyle = '#333';
            radarCtx.beginPath();
            radarCtx.moveTo(radarSize/2, 0);
            radarCtx.lineTo(radarSize/2, radarSize);
            radarCtx.moveTo(0, radarSize/2);
            radarCtx.lineTo(radarSize, radarSize/2);
            radarCtx.stroke();

            // Dessiner les autres joueurs
            Object.values(otherPlayers).forEach(p => {
                // Position relative
                const dx = p.position.x - player.position.x;
                const dz = p.position.z - player.position.z;

                // Rotation par rapport à MON orientation (pour que "Haut" sur radar = "Devant moi")
                // On inverse la rotation du joueur pour tourner le monde autour de lui
                const angle = -player.rotation.y; 
                const rx = dx * Math.cos(angle) - dz * Math.sin(angle);
                const ry = dx * Math.sin(angle) + dz * Math.cos(angle); // ry correspond au Z local

                // Mapping sur le canvas
                // ry devient le Y du canvas (inversé car -Z est devant en ThreeJS, mais +Y est bas en Canvas... 
                // En ThreeJS: -Z est devant.
                // Ici on veut que si l'ennemi est DEVANT (z < 0 local), il soit en HAUT du radar (y < center).
                
                const scale = (radarSize / 2) / radarRange;
                
                // Si dans la portée
                if (Math.abs(rx) < radarRange && Math.abs(ry) < radarRange) {
                    const cx = (radarSize / 2) + rx * scale;
                    const cy = (radarSize / 2) - ry * scale; // Inversion Z -> Y écran

                    radarCtx.fillStyle = 'red';
                    radarCtx.beginPath();
                    radarCtx.arc(cx, cy, 3, 0, Math.PI * 2);
                    radarCtx.fill();
                }
            });

            // Moi (Centre)
            radarCtx.fillStyle = '#0f0';
            radarCtx.beginPath();
            radarCtx.arc(radarSize/2, radarSize/2, 4, 0, Math.PI * 2);
            radarCtx.fill();
            
            // Cône de vision
            radarCtx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
            radarCtx.beginPath();
            radarCtx.moveTo(radarSize/2, radarSize/2);
            radarCtx.lineTo(radarSize/2 - 10, radarSize/2 - 20);
            radarCtx.moveTo(radarSize/2, radarSize/2);
            radarCtx.lineTo(radarSize/2 + 10, radarSize/2 - 20);
            radarCtx.stroke();
        }

        // Redimensionnement
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
