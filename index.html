<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vicdst</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Arial', sans-serif; }
        canvas { display: block; }
        
        #ui-container, #signature, #compass-container {
            position: absolute; z-index: 10; pointer-events: none;
        }

        #ui-container { top: 20px; left: 20px; color: white; text-shadow: 1px 1px 2px black; }
        #signature { bottom: 10px; right: 10px; color: rgba(255, 255, 255, 0.6); font-weight: bold; text-shadow: 1px 1px 1px black; }
        #status { background-color: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px; font-size: 12px; margin-top: 5px; display: inline-block; }

        /* --- STYLES BOUSSOLE (Identiques) --- */
        #compass-container { top: 20px; right: 20px; width: 120px; height: 120px; background-color: rgba(0, 0, 0, 0.5); border-radius: 50%; border: 2px solid white; overflow: hidden; }
        .blip { position: absolute; width: 6px; height: 6px; border-radius: 50%; transform: translate(-50%, -50%); }
        #my-blip { background-color: #00ff00; width: 8px; height: 8px; top: 50%; left: 50%; z-index: 2; }
        
        /* --- STYLES CHAT --- */
        #chat-input-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: none; /* Caché par défaut */
        }
        #chat-input {
            width: 300px;
            padding: 10px;
            font-size: 16px;
            border: 2px solid #fff;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 5px;
        }
        
        /* Conteneur pour toutes les bulles de chat 3D */
        #messages-3d-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Très important pour ne pas bloquer le jeu */
        }
        
        /* Style de la bulle de chat elle-même */
        .chat-bubble {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            white-space: nowrap; /* Empêche le texte de se couper */
            font-size: 16px;
            transform: translate(-50%, -100%); /* Centre horizontalement et monte au-dessus du point de projection */
            pointer-events: none; 
            opacity: 1;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <h1>Forêt Plate Multijoueur</h1>
        <div>Appuyez sur **T** pour discuter.</div>
        <div id="status">Connexion...</div>
    </div>
    
    <div id="compass-container">
        <div id="my-blip" class="blip"></div> 
    </div>

    <div id="messages-3d-container"></div>
    
    <div id="chat-input-container">
        <input type="text" id="chat-input" placeholder="Tapez votre message et appuyez sur ENTRÉE..." maxlength="60">
    </div>

    <div id="signature">Fait par vicdst</div>

    <script src="/socket.io/socket.io.js"></script>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        const socket = io();
        const otherPlayers = {}; 
        const blips = {}; 
        
        // --- CHAT VARIABLES ---
        let isChatting = false;
        const chatInputContainer = document.getElementById('chat-input-container');
        const chatInput = document.getElementById('chat-input');
        const messages3DContainer = document.getElementById('messages-3d-container');
        let activeMessages = {}; // Stocke les messages visibles { id_joueur: { element: div, vector: THREE.Vector3 } }

        // --- PARAMÈTRES DE LA CARTE ---
        const MAP_SIZE = 200; 
        const HALF_MAP = MAP_SIZE / 2;

        socket.on('connect', () => {
            document.getElementById('status').innerText = "Connecté (En ligne)";
            document.getElementById('status').style.color = "#00ff00";
        });

        // --- SCENE SETUP (Reste identique) ---
        const scene = new THREE.Scene();
        const skyColor = 0x87CEEB;
        scene.background = new THREE.Color(skyColor);
        scene.fog = new THREE.Fog(skyColor, 20, 80); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lumières, Sol, Murs, Robots (Fonctions de création non répétées ici) ...
        // [C'est ici qu'on mettrait la création des lumières, du sol, des murs, des robots et des arbres]

        // --- FONCTIONS DE CRÉATION DE MESH (Réintégrées ici pour la complétude) ---
        function createRobot(color) {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshStandardMaterial({ color: color }));
            body.position.y = 0.5; body.castShadow = true; group.add(body);
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), new THREE.MeshStandardMaterial({ color: 0xFFD700 }));
            head.position.y = 1.3; head.castShadow = true; group.add(head);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const e1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.1), eyeMat); e1.position.set(0.15, 1.4, 0.3); group.add(e1);
            const e2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.1), eyeMat); e2.position.set(-0.15, 1.4, 0.3); group.add(e2);
            return group;
        }
        
        // --- MISE EN PLACE DU MONDE (TERRAIN PLAT, MURS, ARBRES) ---
        const geometry = new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE, 1, 1); 
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x2E8B57 });
        const ground = new THREE.Mesh(geometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Lumières (Minimal)
        const ambientLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50); dirLight.castShadow = true;
        dirLight.shadow.camera.top = 50; dirLight.shadow.camera.bottom = -50;
        dirLight.shadow.camera.left = -50; dirLight.shadow.camera.right = 50;
        dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // Murs (Bordures)
        const wallMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
        const wallGeo = new THREE.PlaneGeometry(MAP_SIZE, 20);
        const walls = new THREE.Group();
        const w1 = new THREE.Mesh(wallGeo, wallMat); w1.position.z = -HALF_MAP;
        const w2 = new THREE.Mesh(wallGeo, wallMat); w2.position.z = HALF_MAP;
        const w3 = new THREE.Mesh(wallGeo, wallMat); w3.position.x = -HALF_MAP; w3.rotation.y = Math.PI/2;
        const w4 = new THREE.Mesh(wallGeo, wallMat); w4.position.x = HALF_MAP; w4.rotation.y = Math.PI/2;
        walls.add(w1, w2, w3, w4);
        walls.position.y = 10;
        scene.add(walls);

        const myPlayer = createRobot(0xFF6347);
        myPlayer.position.y = 0.01;
        scene.add(myPlayer);

        function createTree() {
            const grp = new THREE.Group();
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.4, 1.5, 6), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
            trunk.position.y = 0.75; trunk.castShadow = true; grp.add(trunk);
            const leaves = new THREE.Mesh(new THREE.ConeGeometry(1.5, 3, 6), new THREE.MeshStandardMaterial({ color: 0x228B22 }));
            leaves.position.y = 2.2; leaves.castShadow = true; grp.add(leaves);
            return grp;
        }

        for(let i=0; i<100; i++){
            const t = createTree();
            const tx = (Math.random() - 0.5) * (MAP_SIZE - 10);
            const tz = (Math.random() - 0.5) * (MAP_SIZE - 10);
            t.position.set(tx, 0, tz); 
            scene.add(t);
        }

        // --- GESTION MULTIJOUEUR (Reste identique pour les mouvements) ---
        function updateCompass(id, x, z) {
            if (!blips[id]) { /* ... (Création du blip) ... */
                const el = document.createElement('div'); el.className = 'blip'; el.style.backgroundColor = '#ff0000'; document.getElementById('compass-container').appendChild(el); blips[id] = el;
            }
            const radarRange = 50; 
            const dx = x - myPlayer.position.x; const dz = z - myPlayer.position.z;
            const cos = Math.cos(myPlayer.rotation.y); const sin = Math.sin(myPlayer.rotation.y);
            const rx = (dx * cos - dz * sin); const ry = (dx * sin + dz * cos);
            const screenX = (rx / radarRange) * 60; const screenY = (ry / radarRange) * 60;
            const dist = Math.sqrt(screenX * screenX + screenY * screenY);
            if (dist > 55) { blips[id].style.display = 'none'; } else { 
                blips[id].style.display = 'block'; blips[id].style.left = (60 - screenX) + 'px'; blips[id].style.top = (60 + screenY) + 'px'; 
            }
        }
        function addOtherPlayer(id, data) {
            const robot = createRobot(data.color); robot.position.set(data.x, 0.01, data.z); otherPlayers[id] = robot; scene.add(robot);
        }
        socket.on('currentPlayers', (players) => { Object.keys(players).forEach((id) => { if (id !== socket.id) addOtherPlayer(id, players[id]); }); });
        socket.on('newPlayer', (data) => addOtherPlayer(data.id, data.player));
        socket.on('playerDisconnected', (id) => {
            if (otherPlayers[id]) { scene.remove(otherPlayers[id]); delete otherPlayers[id]; }
            if (blips[id]) { blips[id].remove(); delete blips[id]; }
        });
        socket.on('playerMoved', (data) => {
            if (otherPlayers[data.id]) {
                otherPlayers[data.id].position.set(data.x, 0.01, data.z); 
                otherPlayers[data.id].rotation.y = data.rotation;
                updateCompass(data.id, data.x, data.z);
            }
        });

        // --- LOGIQUE CHAT ---

        function displayMessage(playerId, message) {
            const target = (playerId === socket.id) ? myPlayer : otherPlayers[playerId];
            if (!target) return;

            // 1. Suppression de l'ancien message (s'il existe)
            if (activeMessages[playerId]) {
                activeMessages[playerId].element.remove();
                clearTimeout(activeMessages[playerId].timeout);
            }

            // 2. Création de la bulle HTML
            const bubble = document.createElement('div');
            bubble.className = 'chat-bubble';
            bubble.innerText = message;
            messages3DContainer.appendChild(bubble);

            // 3. Création du vecteur 3D pour la projection (position au-dessus de la tête)
            const textVector = new THREE.Vector3(target.position.x, target.position.y + 3, target.position.z);
            
            // 4. Stockage du message actif
            activeMessages[playerId] = {
                element: bubble,
                vector: textVector,
                mesh: target,
                timeout: null
            };

            // 5. Suppression après 5 secondes
            activeMessages[playerId].timeout = setTimeout(() => {
                // Fading out
                bubble.style.opacity = '0'; 
                setTimeout(() => { // Après la transition CSS (0.5s), supprimer l'élément
                    bubble.remove();
                    delete activeMessages[playerId];
                }, 500);
            }, 5000);
        }

        // Réception du message du serveur
        socket.on('receiveMessage', (data) => {
            displayMessage(data.id, data.message);
        });

        // Gestion de la touche T pour ouvrir le chat
        document.addEventListener('keydown', (event) => {
            if (event.code === 'KeyT' && !isChatting) {
                event.preventDefault(); // Empêche le 't' d'être tapé
                isChatting = true;
                chatInputContainer.style.display = 'block';
                chatInput.focus();
            }
        });

        // Gestion de l'envoi (touche ENTRÉE) ou de l'annulation (touche ESC)
        chatInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                const message = chatInput.value.trim();
                if (message) {
                    socket.emit('sendMessage', { message: message });
                }
                
                // Cacher l'interface et réactiver les contrôles
                chatInput.value = '';
                chatInput.blur();
                chatInputContainer.style.display = 'none';
                isChatting = false;
            } else if (event.key === 'Escape') {
                // Annuler
                chatInput.value = '';
                chatInput.blur();
                chatInputContainer.style.display = 'none';
                isChatting = false;
            }
        });

        // --- BOUCLE DE JEU & PROJECTION 3D -> 2D ---
        const keys = { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false };
        window.addEventListener('keydown', e => { 
            if (!isChatting && keys.hasOwnProperty(e.code)) keys[e.code]=true; 
        });
        window.addEventListener('keyup', e => { 
            if (keys.hasOwnProperty(e.code)) keys[e.code]=false; 
        });

        let speed = 0; const maxSpeed = 0.3; const rotSpeed = 0.05;

        function animate() {
            requestAnimationFrame(animate);

            // Le mouvement n'est possible que si on n'est PAS en train de discuter
            if (!isChatting) {
                // Mouvement Local
                if (keys.ArrowUp) speed = Math.min(speed + 0.01, maxSpeed);
                else if (keys.ArrowDown) speed = Math.max(speed - 0.01, -maxSpeed/2);
                else speed = speed > 0 ? Math.max(speed - 0.01, 0) : Math.min(speed + 0.01, 0);

                if (keys.ArrowLeft) myPlayer.rotation.y += rotSpeed;
                if (keys.ArrowRight) myPlayer.rotation.y -= rotSpeed;
                
                // ... (Logique de déplacement et de bordure) ...
                const dx = Math.sin(myPlayer.rotation.y) * speed;
                const dz = Math.cos(myPlayer.rotation.y) * speed;
                let nextX = myPlayer.position.x + dx;
                let nextZ = myPlayer.position.z + dz;

                // LIMITES DE LA MAP
                if (nextX > HALF_MAP - 1) nextX = HALF_MAP - 1;
                if (nextX < -HALF_MAP + 1) nextX = -HALF_MAP + 1;
                if (nextZ > HALF_MAP - 1) nextZ = HALF_MAP - 1;
                if (nextZ < -HALF_MAP + 1) nextZ = -HALF_MAP + 1;

                myPlayer.position.x = nextX;
                myPlayer.position.z = nextZ;
                myPlayer.position.y = 0.01; 

                // Envoyer au serveur (uniquement si on bouge)
                if (speed !== 0 || keys.ArrowLeft || keys.ArrowRight) {
                    socket.emit('playerMovement', { x: myPlayer.position.x, z: myPlayer.position.z, rotation: myPlayer.rotation.y });
                }
            } else {
                // Si on discute, on arrête le mouvement
                speed = 0;
            }

            // Rafraichir le radar pour tous les autres joueurs
            for (let id in otherPlayers) {
                updateCompass(id, otherPlayers[id].position.x, otherPlayers[id].position.z);
            }

            // --- MISE À JOUR DE LA POSITION DES BULLES DE CHAT (PROJECTION) ---
            for (const id in activeMessages) {
                const msg = activeMessages[id];
                const player = msg.mesh;
                
                // Mettre à jour la position 3D si le joueur bouge
                msg.vector.set(player.position.x, player.position.y + 3, player.position.z);

                // Projection de la position 3D vers l'écran 2D
                msg.vector.project(camera);

                // Calcul des coordonnées 2D
                const x = (msg.vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-msg.vector.y * 0.5 + 0.5) * window.innerHeight;

                // Mettre à jour la position CSS
                msg.element.style.left = `${x}px`;
                msg.element.style.top = `${y}px`;
                
                // Gérer l'opacité (cacher si la bulle est derrière la caméra)
                msg.element.style.display = (msg.vector.z > 1) ? 'none' : 'block';
            }

            // Caméra
            const offset = new THREE.Vector3(0, 5, -8).applyMatrix4(myPlayer.matrixWorld);
            camera.position.lerp(offset, 0.1);
            camera.lookAt(myPlayer.position.x, myPlayer.position.y + 2, myPlayer.position.z);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
